{"ast":null,"code":"import { __privateAdd, __privateGet, __privateMethod, __privateSet } from \"./chunk-PXG64RU4.js\";\n\n// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, isValidTimeout, noop, replaceData, resolveEnabled, resolveStaleTime, shallowEqualObjects, timeUntilStale } from \"./utils.js\";\nvar _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn;\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    __privateAdd(this, _QueryObserver_instances);\n    __privateAdd(this, _client);\n    __privateAdd(this, _currentQuery);\n    __privateAdd(this, _currentQueryInitialState);\n    __privateAdd(this, _currentResult);\n    __privateAdd(this, _currentResultState);\n    __privateAdd(this, _currentResultOptions);\n    __privateAdd(this, _currentThenable);\n    __privateAdd(this, _selectError);\n    __privateAdd(this, _selectFn);\n    __privateAdd(this, _selectResult);\n    // This property keeps track of the last query with defined data.\n    // It will be used to pass the previous data and query to the placeholder function between renders.\n    __privateAdd(this, _lastQueryWithDefinedData);\n    __privateAdd(this, _staleTimeoutId);\n    __privateAdd(this, _refetchIntervalId);\n    __privateAdd(this, _currentRefetchInterval);\n    __privateAdd(this, _trackedProps, /* @__PURE__ */new Set());\n    __privateSet(this, _client, client);\n    __privateSet(this, _selectError, null);\n    __privateSet(this, _currentThenable, pendingThenable());\n    if (!this.options.experimental_prefetchInRender) {\n      __privateGet(this, _currentThenable).reject(new Error(\"experimental_prefetchInRender feature flag is not enabled\"));\n    }\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      __privateGet(this, _currentQuery).addObserver(this);\n      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {\n        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);\n      } else {\n        this.updateResult();\n      }\n      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(__privateGet(this, _currentQuery), this.options, this.options.refetchOnReconnect);\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(__privateGet(this, _currentQuery), this.options, this.options.refetchOnWindowFocus);\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */new Set();\n    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);\n    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);\n    __privateGet(this, _currentQuery).removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = __privateGet(this, _currentQuery);\n    this.options = __privateGet(this, _client).defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== \"boolean\") {\n      throw new Error(\"Expected enabled to be a boolean or a callback that returns a boolean\");\n    }\n    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);\n    __privateGet(this, _currentQuery).setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      __privateGet(this, _client).getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: __privateGet(this, _currentQuery),\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(__privateGet(this, _currentQuery), prevQuery, this.options, prevOptions)) {\n      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);\n    }\n    this.updateResult();\n    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {\n      __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);\n    }\n    const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);\n    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {\n      __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      __privateSet(this, _currentResult, result);\n      __privateSet(this, _currentResultOptions, this.options);\n      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return __privateGet(this, _currentResult);\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked == null ? void 0 : onPropTracked(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    __privateGet(this, _trackedProps).add(key);\n  }\n  getCurrentQuery() {\n    return __privateGet(this, _currentQuery);\n  }\n  refetch({\n    ...options\n  } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = __privateGet(this, _client).defaultQueryOptions(options);\n    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return __privateGet(this, _currentResult);\n    });\n  }\n  createResult(query, options) {\n    var _a;\n    const prevQuery = __privateGet(this, _currentQuery);\n    const prevOptions = this.options;\n    const prevResult = __privateGet(this, _currentResult);\n    const prevResultState = __privateGet(this, _currentResultState);\n    const prevResultOptions = __privateGet(this, _currentResultOptions);\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);\n    const {\n      state\n    } = query;\n    let newState = {\n      ...state\n    };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let {\n      error,\n      errorUpdatedAt,\n      status\n    } = newState;\n    if (options.select && newState.data !== void 0) {\n      if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {\n        data = __privateGet(this, _selectResult);\n      } else {\n        try {\n          __privateSet(this, _selectFn, options.select);\n          data = options.select(newState.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          __privateSet(this, _selectResult, data);\n          __privateSet(this, _selectError, null);\n        } catch (selectError) {\n          __privateSet(this, _selectError, selectError);\n        }\n      }\n    } else {\n      data = newState.data;\n    }\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData((_a = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a.state.data, __privateGet(this, _lastQueryWithDefinedData)) : options.placeholderData;\n        if (options.select && placeholderData !== void 0) {\n          try {\n            placeholderData = options.select(placeholderData);\n            __privateSet(this, _selectError, null);\n          } catch (selectError) {\n            __privateSet(this, _selectError, selectError);\n          }\n        }\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n    if (__privateGet(this, _selectError)) {\n      error = __privateGet(this, _selectError);\n      data = __privateGet(this, _selectResult);\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: __privateGet(this, _currentThenable)\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = thenable => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = __privateSet(this, _currentThenable, nextResult.promise = pendingThenable());\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = __privateGet(this, _currentThenable);\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = __privateGet(this, _currentResult);\n    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);\n    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);\n    __privateSet(this, _currentResultOptions, this.options);\n    if (__privateGet(this, _currentResultState).data !== void 0) {\n      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    __privateSet(this, _currentResult, nextResult);\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {\n        return true;\n      }\n      const includedProps = new Set(notifyOnChangePropsValue ?? __privateGet(this, _trackedProps));\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(__privateGet(this, _currentResult)).some(key => {\n        const typedKey = key;\n        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, {\n      listeners: shouldNotifyListeners()\n    });\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);\n    }\n  }\n};\n_client = new WeakMap();\n_currentQuery = new WeakMap();\n_currentQueryInitialState = new WeakMap();\n_currentResult = new WeakMap();\n_currentResultState = new WeakMap();\n_currentResultOptions = new WeakMap();\n_currentThenable = new WeakMap();\n_selectError = new WeakMap();\n_selectFn = new WeakMap();\n_selectResult = new WeakMap();\n_lastQueryWithDefinedData = new WeakMap();\n_staleTimeoutId = new WeakMap();\n_refetchIntervalId = new WeakMap();\n_currentRefetchInterval = new WeakMap();\n_trackedProps = new WeakMap();\n_QueryObserver_instances = new WeakSet();\nexecuteFetch_fn = function (fetchOptions) {\n  __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);\n  let promise = __privateGet(this, _currentQuery).fetch(this.options, fetchOptions);\n  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {\n    promise = promise.catch(noop);\n  }\n  return promise;\n};\nupdateStaleTimeout_fn = function () {\n  __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);\n  const staleTime = resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery));\n  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {\n    return;\n  }\n  const time = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);\n  const timeout = time + 1;\n  __privateSet(this, _staleTimeoutId, setTimeout(() => {\n    if (!__privateGet(this, _currentResult).isStale) {\n      this.updateResult();\n    }\n  }, timeout));\n};\ncomputeRefetchInterval_fn = function () {\n  return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;\n};\nupdateRefetchInterval_fn = function (nextInterval) {\n  __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);\n  __privateSet(this, _currentRefetchInterval, nextInterval);\n  if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {\n    return;\n  }\n  __privateSet(this, _refetchIntervalId, setInterval(() => {\n    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);\n    }\n  }, __privateGet(this, _currentRefetchInterval)));\n};\nupdateTimers_fn = function () {\n  __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);\n  __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));\n};\nclearStaleTimeout_fn = function () {\n  if (__privateGet(this, _staleTimeoutId)) {\n    clearTimeout(__privateGet(this, _staleTimeoutId));\n    __privateSet(this, _staleTimeoutId, void 0);\n  }\n};\nclearRefetchInterval_fn = function () {\n  if (__privateGet(this, _refetchIntervalId)) {\n    clearInterval(__privateGet(this, _refetchIntervalId));\n    __privateSet(this, _refetchIntervalId, void 0);\n  }\n};\nupdateQuery_fn = function () {\n  const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), this.options);\n  if (query === __privateGet(this, _currentQuery)) {\n    return;\n  }\n  const prevQuery = __privateGet(this, _currentQuery);\n  __privateSet(this, _currentQuery, query);\n  __privateSet(this, _currentQueryInitialState, query.state);\n  if (this.hasListeners()) {\n    prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n    query.addObserver(this);\n  }\n};\nnotify_fn = function (notifyOptions) {\n  notifyManager.batch(() => {\n    if (notifyOptions.listeners) {\n      this.listeners.forEach(listener => {\n        listener(__privateGet(this, _currentResult));\n      });\n    }\n    __privateGet(this, _client).getQueryCache().notify({\n      query: __privateGet(this, _currentQuery),\n      type: \"observerResultsUpdated\"\n    });\n  });\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport { QueryObserver };","map":{"version":3,"names":["__privateAdd","__privateGet","__privateMethod","__privateSet","focusManager","notifyManager","fetchState","Subscribable","pendingThenable","isServer","isValidTimeout","noop","replaceData","resolveEnabled","resolveStaleTime","shallowEqualObjects","timeUntilStale","_client","_currentQuery","_currentQueryInitialState","_currentResult","_currentResultState","_currentResultOptions","_currentThenable","_selectError","_selectFn","_selectResult","_lastQueryWithDefinedData","_staleTimeoutId","_refetchIntervalId","_currentRefetchInterval","_trackedProps","_QueryObserver_instances","executeFetch_fn","updateStaleTimeout_fn","computeRefetchInterval_fn","updateRefetchInterval_fn","updateTimers_fn","clearStaleTimeout_fn","clearRefetchInterval_fn","updateQuery_fn","notify_fn","QueryObserver","constructor","client","options","Set","experimental_prefetchInRender","reject","Error","bindMethods","setOptions","refetch","bind","onSubscribe","listeners","size","addObserver","shouldFetchOnMount","call","updateResult","onUnsubscribe","hasListeners","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","removeObserver","prevOptions","prevQuery","defaultQueryOptions","enabled","_defaulted","getQueryCache","notify","type","query","observer","mounted","shouldFetchOptionally","staleTime","nextRefetchInterval","getOptimisticResult","build","result","createResult","shouldAssignObserverCurrentProperties","state","getCurrentResult","trackResult","onPropTracked","trackedResult","Object","keys","forEach","key","defineProperty","configurable","enumerable","get","trackProp","add","getCurrentQuery","fetch","fetchOptimistic","defaultedOptions","then","fetchOptions","cancelRefetch","_a","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","newState","isPlaceholderData","data","_optimisticResults","fetchOnMount","fetchOptionally","fetchStatus","error","errorUpdatedAt","status","select","selectError","placeholderData","Date","now","isFetching","isPending","isError","isLoading","hasData","isSuccess","isInitialLoading","dataUpdatedAt","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","isStale","promise","nextResult","finalizeThenableIfPossible","thenable","resolve","recreateThenable","pending","prevThenable","queryHash","value","reason","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","throwOnError","some","typedKey","changed","has","onQueryUpdate","WeakMap","WeakSet","catch","time","timeout","setTimeout","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","clearInterval","notifyOptions","batch","listener","shouldLoadOnMount","retryOnMount","refetchOnMount","field","suspense","isStaleByTime","optimisticResult"],"sources":["/Users/bts-ank-0608/Final-Project/frontend/node_modules/@tanstack/query-core/build/legacy/queryObserver.js"],"sourcesContent":["import {\n  __privateAdd,\n  __privateGet,\n  __privateMethod,\n  __privateSet\n} from \"./chunk-PXG64RU4.js\";\n\n// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nvar _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn;\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    __privateAdd(this, _QueryObserver_instances);\n    __privateAdd(this, _client);\n    __privateAdd(this, _currentQuery);\n    __privateAdd(this, _currentQueryInitialState);\n    __privateAdd(this, _currentResult);\n    __privateAdd(this, _currentResultState);\n    __privateAdd(this, _currentResultOptions);\n    __privateAdd(this, _currentThenable);\n    __privateAdd(this, _selectError);\n    __privateAdd(this, _selectFn);\n    __privateAdd(this, _selectResult);\n    // This property keeps track of the last query with defined data.\n    // It will be used to pass the previous data and query to the placeholder function between renders.\n    __privateAdd(this, _lastQueryWithDefinedData);\n    __privateAdd(this, _staleTimeoutId);\n    __privateAdd(this, _refetchIntervalId);\n    __privateAdd(this, _currentRefetchInterval);\n    __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());\n    __privateSet(this, _client, client);\n    __privateSet(this, _selectError, null);\n    __privateSet(this, _currentThenable, pendingThenable());\n    if (!this.options.experimental_prefetchInRender) {\n      __privateGet(this, _currentThenable).reject(\n        new Error(\"experimental_prefetchInRender feature flag is not enabled\")\n      );\n    }\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      __privateGet(this, _currentQuery).addObserver(this);\n      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {\n        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);\n      } else {\n        this.updateResult();\n      }\n      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      __privateGet(this, _currentQuery),\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      __privateGet(this, _currentQuery),\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);\n    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);\n    __privateGet(this, _currentQuery).removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = __privateGet(this, _currentQuery);\n    this.options = __privateGet(this, _client).defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);\n    __privateGet(this, _currentQuery).setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      __privateGet(this, _client).getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: __privateGet(this, _currentQuery),\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      __privateGet(this, _currentQuery),\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);\n    }\n    this.updateResult();\n    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {\n      __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);\n    }\n    const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);\n    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {\n      __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      __privateSet(this, _currentResult, result);\n      __privateSet(this, _currentResultOptions, this.options);\n      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return __privateGet(this, _currentResult);\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked == null ? void 0 : onPropTracked(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    __privateGet(this, _trackedProps).add(key);\n  }\n  getCurrentQuery() {\n    return __privateGet(this, _currentQuery);\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = __privateGet(this, _client).defaultQueryOptions(options);\n    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return __privateGet(this, _currentResult);\n    });\n  }\n  createResult(query, options) {\n    var _a;\n    const prevQuery = __privateGet(this, _currentQuery);\n    const prevOptions = this.options;\n    const prevResult = __privateGet(this, _currentResult);\n    const prevResultState = __privateGet(this, _currentResultState);\n    const prevResultOptions = __privateGet(this, _currentResultOptions);\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    if (options.select && newState.data !== void 0) {\n      if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {\n        data = __privateGet(this, _selectResult);\n      } else {\n        try {\n          __privateSet(this, _selectFn, options.select);\n          data = options.select(newState.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          __privateSet(this, _selectResult, data);\n          __privateSet(this, _selectError, null);\n        } catch (selectError) {\n          __privateSet(this, _selectError, selectError);\n        }\n      }\n    } else {\n      data = newState.data;\n    }\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          (_a = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a.state.data,\n          __privateGet(this, _lastQueryWithDefinedData)\n        ) : options.placeholderData;\n        if (options.select && placeholderData !== void 0) {\n          try {\n            placeholderData = options.select(placeholderData);\n            __privateSet(this, _selectError, null);\n          } catch (selectError) {\n            __privateSet(this, _selectError, selectError);\n          }\n        }\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult == null ? void 0 : prevResult.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (__privateGet(this, _selectError)) {\n      error = __privateGet(this, _selectError);\n      data = __privateGet(this, _selectResult);\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: __privateGet(this, _currentThenable)\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable) => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = __privateSet(this, _currentThenable, nextResult.promise = pendingThenable());\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = __privateGet(this, _currentThenable);\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = __privateGet(this, _currentResult);\n    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);\n    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);\n    __privateSet(this, _currentResultOptions, this.options);\n    if (__privateGet(this, _currentResultState).data !== void 0) {\n      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    __privateSet(this, _currentResult, nextResult);\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(__privateGet(this, _currentResult)).some((key) => {\n        const typedKey = key;\n        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { listeners: shouldNotifyListeners() });\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);\n    }\n  }\n};\n_client = new WeakMap();\n_currentQuery = new WeakMap();\n_currentQueryInitialState = new WeakMap();\n_currentResult = new WeakMap();\n_currentResultState = new WeakMap();\n_currentResultOptions = new WeakMap();\n_currentThenable = new WeakMap();\n_selectError = new WeakMap();\n_selectFn = new WeakMap();\n_selectResult = new WeakMap();\n_lastQueryWithDefinedData = new WeakMap();\n_staleTimeoutId = new WeakMap();\n_refetchIntervalId = new WeakMap();\n_currentRefetchInterval = new WeakMap();\n_trackedProps = new WeakMap();\n_QueryObserver_instances = new WeakSet();\nexecuteFetch_fn = function(fetchOptions) {\n  __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);\n  let promise = __privateGet(this, _currentQuery).fetch(\n    this.options,\n    fetchOptions\n  );\n  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {\n    promise = promise.catch(noop);\n  }\n  return promise;\n};\nupdateStaleTimeout_fn = function() {\n  __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);\n  const staleTime = resolveStaleTime(\n    this.options.staleTime,\n    __privateGet(this, _currentQuery)\n  );\n  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {\n    return;\n  }\n  const time = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);\n  const timeout = time + 1;\n  __privateSet(this, _staleTimeoutId, setTimeout(() => {\n    if (!__privateGet(this, _currentResult).isStale) {\n      this.updateResult();\n    }\n  }, timeout));\n};\ncomputeRefetchInterval_fn = function() {\n  return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;\n};\nupdateRefetchInterval_fn = function(nextInterval) {\n  __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);\n  __privateSet(this, _currentRefetchInterval, nextInterval);\n  if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {\n    return;\n  }\n  __privateSet(this, _refetchIntervalId, setInterval(() => {\n    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);\n    }\n  }, __privateGet(this, _currentRefetchInterval)));\n};\nupdateTimers_fn = function() {\n  __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);\n  __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));\n};\nclearStaleTimeout_fn = function() {\n  if (__privateGet(this, _staleTimeoutId)) {\n    clearTimeout(__privateGet(this, _staleTimeoutId));\n    __privateSet(this, _staleTimeoutId, void 0);\n  }\n};\nclearRefetchInterval_fn = function() {\n  if (__privateGet(this, _refetchIntervalId)) {\n    clearInterval(__privateGet(this, _refetchIntervalId));\n    __privateSet(this, _refetchIntervalId, void 0);\n  }\n};\nupdateQuery_fn = function() {\n  const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), this.options);\n  if (query === __privateGet(this, _currentQuery)) {\n    return;\n  }\n  const prevQuery = __privateGet(this, _currentQuery);\n  __privateSet(this, _currentQuery, query);\n  __privateSet(this, _currentQueryInitialState, query.state);\n  if (this.hasListeners()) {\n    prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n    query.addObserver(this);\n  }\n};\nnotify_fn = function(notifyOptions) {\n  notifyManager.batch(() => {\n    if (notifyOptions.listeners) {\n      this.listeners.forEach((listener) => {\n        listener(__privateGet(this, _currentResult));\n      });\n    }\n    __privateGet(this, _client).getQueryCache().notify({\n      query: __privateGet(this, _currentQuery),\n      type: \"observerResultsUpdated\"\n    });\n  });\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}