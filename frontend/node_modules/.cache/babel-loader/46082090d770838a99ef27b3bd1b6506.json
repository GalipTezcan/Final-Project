{"ast":null,"code":"import \"./chunk-PXG64RU4.js\";\n\n// src/hydration.ts\nfunction defaultTransformerFn(data) {\n  return data;\n}\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...(mutation.options.scope && {\n      scope: mutation.options.scope\n    }),\n    ...(mutation.meta && {\n      meta: mutation.meta\n    })\n  };\n}\nfunction dehydrateQuery(query, serializeData, shouldRedactErrors) {\n  var _a;\n  return {\n    state: {\n      ...query.state,\n      ...(query.state.data !== void 0 && {\n        data: serializeData(query.state.data)\n      })\n    },\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...(query.state.status === \"pending\" && {\n      promise: (_a = query.promise) == null ? void 0 : _a.then(serializeData).catch(error => {\n        if (!shouldRedactErrors(error)) {\n          return Promise.reject(error);\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n          console.error(`A query that was dehydrated as pending ended up rejecting. [${query.queryHash}]: ${error}; The error will be redacted in production builds`);\n        }\n        return Promise.reject(new Error(\"redacted\"));\n      })\n    }),\n    ...(query.meta && {\n      meta: query.meta\n    })\n  };\n}\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === \"success\";\n}\nfunction defaultShouldRedactErrors(_) {\n  return true;\n}\nfunction dehydrate(client, options = {}) {\n  var _a, _b, _c, _d;\n  const filterMutation = options.shouldDehydrateMutation ?? ((_a = client.getDefaultOptions().dehydrate) == null ? void 0 : _a.shouldDehydrateMutation) ?? defaultShouldDehydrateMutation;\n  const mutations = client.getMutationCache().getAll().flatMap(mutation => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []);\n  const filterQuery = options.shouldDehydrateQuery ?? ((_b = client.getDefaultOptions().dehydrate) == null ? void 0 : _b.shouldDehydrateQuery) ?? defaultShouldDehydrateQuery;\n  const shouldRedactErrors = options.shouldRedactErrors ?? ((_c = client.getDefaultOptions().dehydrate) == null ? void 0 : _c.shouldRedactErrors) ?? defaultShouldRedactErrors;\n  const serializeData = options.serializeData ?? ((_d = client.getDefaultOptions().dehydrate) == null ? void 0 : _d.serializeData) ?? defaultTransformerFn;\n  const queries = client.getQueryCache().getAll().flatMap(query => filterQuery(query) ? [dehydrateQuery(query, serializeData, shouldRedactErrors)] : []);\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  var _a, _b;\n  if (typeof dehydratedState !== \"object\" || dehydratedState === null) {\n    return;\n  }\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache();\n  const deserializeData = ((_a = options == null ? void 0 : options.defaultOptions) == null ? void 0 : _a.deserializeData) ?? ((_b = client.getDefaultOptions().hydrate) == null ? void 0 : _b.deserializeData) ?? defaultTransformerFn;\n  const mutations = dehydratedState.mutations || [];\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(({\n    state,\n    ...mutationOptions\n  }) => {\n    var _a2, _b2;\n    mutationCache.build(client, {\n      ...((_a2 = client.getDefaultOptions().hydrate) == null ? void 0 : _a2.mutations),\n      ...((_b2 = options == null ? void 0 : options.defaultOptions) == null ? void 0 : _b2.mutations),\n      ...mutationOptions\n    }, state);\n  });\n  queries.forEach(({\n    queryKey,\n    state,\n    queryHash,\n    meta,\n    promise\n  }) => {\n    var _a2, _b2;\n    let query = queryCache.get(queryHash);\n    const data = state.data === void 0 ? state.data : deserializeData(state.data);\n    if (query) {\n      if (query.state.dataUpdatedAt < state.dataUpdatedAt) {\n        const {\n          fetchStatus: _ignored,\n          ...serializedState\n        } = state;\n        query.setState({\n          ...serializedState,\n          data\n        });\n      }\n    } else {\n      query = queryCache.build(client, {\n        ...((_a2 = client.getDefaultOptions().hydrate) == null ? void 0 : _a2.queries),\n        ...((_b2 = options == null ? void 0 : options.defaultOptions) == null ? void 0 : _b2.queries),\n        queryKey,\n        queryHash,\n        meta\n      },\n      // Reset fetch status to idle to avoid\n      // query being stuck in fetching state upon hydration\n      {\n        ...state,\n        data,\n        fetchStatus: \"idle\"\n      });\n    }\n    if (promise) {\n      const initialPromise = Promise.resolve(promise).then(deserializeData);\n      void query.fetch(void 0, {\n        initialPromise\n      });\n    }\n  });\n}\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate };","map":{"version":3,"names":["defaultTransformerFn","data","dehydrateMutation","mutation","mutationKey","options","state","scope","meta","dehydrateQuery","query","serializeData","shouldRedactErrors","_a","queryKey","queryHash","status","promise","then","catch","error","Promise","reject","process","env","NODE_ENV","console","Error","defaultShouldDehydrateMutation","isPaused","defaultShouldDehydrateQuery","defaultShouldRedactErrors","_","dehydrate","client","_b","_c","_d","filterMutation","shouldDehydrateMutation","getDefaultOptions","mutations","getMutationCache","getAll","flatMap","filterQuery","shouldDehydrateQuery","queries","getQueryCache","hydrate","dehydratedState","mutationCache","queryCache","deserializeData","defaultOptions","forEach","mutationOptions","_a2","_b2","build","get","dataUpdatedAt","fetchStatus","_ignored","serializedState","setState","initialPromise","resolve","fetch"],"sources":["/Users/bts-ank-0608/Final-Project/frontend/node_modules/@tanstack/query-core/build/legacy/hydration.js"],"sourcesContent":["import \"./chunk-PXG64RU4.js\";\n\n// src/hydration.ts\nfunction defaultTransformerFn(data) {\n  return data;\n}\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...mutation.options.scope && { scope: mutation.options.scope },\n    ...mutation.meta && { meta: mutation.meta }\n  };\n}\nfunction dehydrateQuery(query, serializeData, shouldRedactErrors) {\n  var _a;\n  return {\n    state: {\n      ...query.state,\n      ...query.state.data !== void 0 && {\n        data: serializeData(query.state.data)\n      }\n    },\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...query.state.status === \"pending\" && {\n      promise: (_a = query.promise) == null ? void 0 : _a.then(serializeData).catch((error) => {\n        if (!shouldRedactErrors(error)) {\n          return Promise.reject(error);\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n          console.error(\n            `A query that was dehydrated as pending ended up rejecting. [${query.queryHash}]: ${error}; The error will be redacted in production builds`\n          );\n        }\n        return Promise.reject(new Error(\"redacted\"));\n      })\n    },\n    ...query.meta && { meta: query.meta }\n  };\n}\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === \"success\";\n}\nfunction defaultShouldRedactErrors(_) {\n  return true;\n}\nfunction dehydrate(client, options = {}) {\n  var _a, _b, _c, _d;\n  const filterMutation = options.shouldDehydrateMutation ?? ((_a = client.getDefaultOptions().dehydrate) == null ? void 0 : _a.shouldDehydrateMutation) ?? defaultShouldDehydrateMutation;\n  const mutations = client.getMutationCache().getAll().flatMap(\n    (mutation) => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []\n  );\n  const filterQuery = options.shouldDehydrateQuery ?? ((_b = client.getDefaultOptions().dehydrate) == null ? void 0 : _b.shouldDehydrateQuery) ?? defaultShouldDehydrateQuery;\n  const shouldRedactErrors = options.shouldRedactErrors ?? ((_c = client.getDefaultOptions().dehydrate) == null ? void 0 : _c.shouldRedactErrors) ?? defaultShouldRedactErrors;\n  const serializeData = options.serializeData ?? ((_d = client.getDefaultOptions().dehydrate) == null ? void 0 : _d.serializeData) ?? defaultTransformerFn;\n  const queries = client.getQueryCache().getAll().flatMap(\n    (query) => filterQuery(query) ? [dehydrateQuery(query, serializeData, shouldRedactErrors)] : []\n  );\n  return { mutations, queries };\n}\nfunction hydrate(client, dehydratedState, options) {\n  var _a, _b;\n  if (typeof dehydratedState !== \"object\" || dehydratedState === null) {\n    return;\n  }\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache();\n  const deserializeData = ((_a = options == null ? void 0 : options.defaultOptions) == null ? void 0 : _a.deserializeData) ?? ((_b = client.getDefaultOptions().hydrate) == null ? void 0 : _b.deserializeData) ?? defaultTransformerFn;\n  const mutations = dehydratedState.mutations || [];\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(({ state, ...mutationOptions }) => {\n    var _a2, _b2;\n    mutationCache.build(\n      client,\n      {\n        ...(_a2 = client.getDefaultOptions().hydrate) == null ? void 0 : _a2.mutations,\n        ...(_b2 = options == null ? void 0 : options.defaultOptions) == null ? void 0 : _b2.mutations,\n        ...mutationOptions\n      },\n      state\n    );\n  });\n  queries.forEach(({ queryKey, state, queryHash, meta, promise }) => {\n    var _a2, _b2;\n    let query = queryCache.get(queryHash);\n    const data = state.data === void 0 ? state.data : deserializeData(state.data);\n    if (query) {\n      if (query.state.dataUpdatedAt < state.dataUpdatedAt) {\n        const { fetchStatus: _ignored, ...serializedState } = state;\n        query.setState({\n          ...serializedState,\n          data\n        });\n      }\n    } else {\n      query = queryCache.build(\n        client,\n        {\n          ...(_a2 = client.getDefaultOptions().hydrate) == null ? void 0 : _a2.queries,\n          ...(_b2 = options == null ? void 0 : options.defaultOptions) == null ? void 0 : _b2.queries,\n          queryKey,\n          queryHash,\n          meta\n        },\n        // Reset fetch status to idle to avoid\n        // query being stuck in fetching state upon hydration\n        {\n          ...state,\n          data,\n          fetchStatus: \"idle\"\n        }\n      );\n    }\n    if (promise) {\n      const initialPromise = Promise.resolve(promise).then(deserializeData);\n      void query.fetch(void 0, { initialPromise });\n    }\n  });\n}\nexport {\n  defaultShouldDehydrateMutation,\n  defaultShouldDehydrateQuery,\n  dehydrate,\n  hydrate\n};\n//# sourceMappingURL=hydration.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}